% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv_trendfilter_D1.R
\name{cv_trendfilter_D1}
\alias{cv_trendfilter_D1}
\title{Cross-validation for two-penalty trend filtering}
\usage{
cv_trendfilter_D1(
  y,
  x = seq_along(y),
  k = 3L,
  lambda1_scalar = c(0.1, 0.2, 0.5, 0.7, 1, 1.5, 2, 10),
  nfolds = 5L,
  nlambda = 50L,
  lambda_max = NULL,
  lambda_min_ratio = 1e-05,
  ...
)
}
\arguments{
\item{y}{Numeric vector of observations.}

\item{x}{Numeric vector of the same length as \code{y};
defaults to \code{1:length(y)}.}

\item{k}{Polynomial order of the trend filter (default 3).}

\item{lambda1_scalar}{Numeric vector of multipliers
\eqn{\rho} so that \eqn{\lambda_1 = \rho\,\lambda_k}.}

\item{nfolds}{Integer \(\ge 2\).  Number of CV folds (leave-v-th-out).}

\item{nlambda}{Number of distinct \eqn{\lambda_k} values along the path.}

\item{lambda_max}{Optional; maximum \eqn{\lambda_k}.
If \code{NULL} it is computed via \code{get_lambda_max()}.}

\item{lambda_min_ratio}{Smallest \eqn{\lambda_k} is
\code{lambda_max * lambda_min_ratio}.}

\item{...}{Additional arguments forwarded to \code{trendfilter_D1()}.}
}
\value{
A list of class \code{"cv_trendfilter_D1"} with elements
\describe{
\item{\code{lambdak}}{numeric vector of \eqn{\lambda_k}.}
\item{\code{lambda1_scalar}}{the scalar grid supplied.}
\item{\code{cv_scores}}{matrix \eqn{nlambda \times length(lambda1_scalar)}
of averaged MSEs.  Row = \eqn{\lambda_k}, column = scalar.}
\item{\code{scalar_min}}{data frame of length \eqn{nlambda} giving,
for each \eqn{\lambda_k}, the scalar that minimises CV error.}
\item{\code{call}}{the matched call.}
}
}
\description{
Performs leave-v-th-out cross-validation over a \strong{2-D grid}:
a sequence of \eqn{\lambda_k} values (high-order penalty) and a
\emph{scalar} grid that multiplies \eqn{\lambda_k} to obtain
\eqn{\lambda_1}.
}
\details{
For each combination of \eqn{(\lambda_k,\;\rho)} it
\enumerate{
\item fits \code{trendfilter_D1()} on the training folds,
\item predicts on the held-out fold via \code{predict.trendfilter_D1()},
\item stores the mean-squared error.
}
The output gives the full CV error surface and, for every \eqn{\lambda_k},
the scalar that minimises the CV score.
}
\examples{
\dontrun{
set.seed(1)
x <- 1:40
y <- c(rep(3, 10), rep(2, 15), seq(2, -2, length = 15))
cv2d <- cv_trendfilter_D1(y, x, k = 2)
head(cv2d$scalar_min)
}

}
